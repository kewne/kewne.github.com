---
layout: blog_post
title: Reducing tests based on method call verication
has_code: true
---
Out of the today's programming practices, testing is probably one of the few
that is widely accepted.
However, in my opinion, test code tends to be written with less care and,
as a consequence, to rot much more quickly than application code.
Something I see much more commonly than I would like to is method call verification in tests.
Using Mockito in Java it looks something like this:

{% highlight java %}
public void shouldPlaceOrder() {
    OrderRepository repo = mock(OrderRepository.class);
    OrderService service = new DefaultOrderService(repo);
    List<Order> orders = new ArrayList<>();
    orders.add(new Order("book"));
    orders.add(new Order("movie"));
    service.placeOrders(orders);
    verify(repo, times(2))
        .save(any(Order.class));
}
{% endhighlight %}

The problem with this is that, despite working, it breaks very easily, because it's leaking the implementation of `OrderService`: without even looking at the class' implementation, we know that it calls the `save` method on the `OrderRepository` twice.
This test will break every single time the method calls change, which, besides the obvious extra work involved, makes changes more risky since you can't just change the implementation and verify it against the same test as the previous version.

Another thing that bugs me is that, even when you take the time to capture arguments and perform assertions on them, you're still relying on that method being called, instead of on the underlying behavior.
*Something should have changed when that method was called* and that's the assertion that should be made.

{% highlight java %}
public interface OrderService {
  /**
  *  Places an order.
  *  Placement of an order may fail due to one of the following:
  *  1) There is no stock for at least one of the items in the order
  *  2) The purchasing customer doesn't have the funds to pay for the order
  *  3) Various issues accessing a datastore or the network
  *  @throws OrderPlacementException when there is a miscellaneous 
  *    error placing the order
  */
  PlacementResult placeOrder(Order o);

  public enum PlacementResult {
    NoStock,
    NoFunds,   
    Ok
  }
}
{% endhighlight %}

`OrderService` can be implemented by using webservice calls, calling a datastore or using in-memory structures, but the essential test case assertions are the same (I've ommitted the setup logic because that's necessarily implementation-dependent):

{% highlight java %}
public void testOrderPlacedOk(OrderService uut, Order o) {
  assertEquals(Ok, uut.placeOrder(order));    
}

public void testOrderPlacedNoStock(OrderService uut, Order o) {
  assertEquals(NoStock, uut.placeOrder(order));    
}

public void testOrderPlacedNoFunds(OrderService uut, Order o) {
  assertEquals(NoFunds, uut.placeOrder(order));   
}
{% endhighlight %}

Let me say it again: *regardless of the implementation, the above tests should always pass*.

Now actually, there is an extra test case:

{% highlight java %}
public void testOrderFailedException(OrderService uut, Order o) {
  try {
    uut.placeOrder(order);
    fail("Should have thrown"); //Actually, should have used a @Rule
  } catch (OrderPlacementException e) {
    // maybe assertions, usually a bad practice for another post
  } 
}
{% endhighlight %}

This test case is more complicated because, despite the behavior being the same when there is a failure, the causes of failure are left open and are implementation dependent...but I wouldn't be writing a post about it if I didn't think I had a solution!
The solution is that, for any implementation of `OrderService`, the failure modes will depend on its collaborating objects, which means that, if we combine the failure modes of all collaborators, we get the possible failure modes of the `OrderService` implementation.

Although this is very good in theory, finding all the combinations is...well...combinatorial, which easily amounts to dozens of failure modes.
In practice, many of the combinations produce the same failure modes, so it's ok to look under the hood and see what the minimal number of cases is.
This could lead to some coupling but not much and not necessarily, suppose `placeOrder` is implemented like this:

